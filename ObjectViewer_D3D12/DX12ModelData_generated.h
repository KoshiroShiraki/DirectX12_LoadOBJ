// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DX12MODELDATA_DX12MODELDATA_H_
#define FLATBUFFERS_GENERATED_DX12MODELDATA_DX12MODELDATA_H_

#include "flatbuffers/flatbuffers.h"

namespace DX12ModelData {

struct Position;

struct Normal;

struct UV;

struct Color;

struct Vertex;
struct VertexBuilder;

struct Material;
struct MaterialBuilder;

struct ModelChild;
struct ModelChildBuilder;

struct ModelParent;
struct ModelParentBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Position FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Position()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Position(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Position, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Normal FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Normal()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Normal(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Normal, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) UV FLATBUFFERS_FINAL_CLASS {
 private:
  float u_;
  float v_;

 public:
  UV()
      : u_(0),
        v_(0) {
  }
  UV(float _u, float _v)
      : u_(flatbuffers::EndianScalar(_u)),
        v_(flatbuffers::EndianScalar(_v)) {
  }
  float u() const {
    return flatbuffers::EndianScalar(u_);
  }
  float v() const {
    return flatbuffers::EndianScalar(v_);
  }
};
FLATBUFFERS_STRUCT_END(UV, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Color FLATBUFFERS_FINAL_CLASS {
 private:
  float r_;
  float g_;
  float b_;

 public:
  Color()
      : r_(0),
        g_(0),
        b_(0) {
  }
  Color(float _r, float _g, float _b)
      : r_(flatbuffers::EndianScalar(_r)),
        g_(flatbuffers::EndianScalar(_g)),
        b_(flatbuffers::EndianScalar(_b)) {
  }
  float r() const {
    return flatbuffers::EndianScalar(r_);
  }
  float g() const {
    return flatbuffers::EndianScalar(g_);
  }
  float b() const {
    return flatbuffers::EndianScalar(b_);
  }
};
FLATBUFFERS_STRUCT_END(Color, 12);

struct Vertex FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VertexBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_NORM = 6,
    VT_UV = 8
  };
  const DX12ModelData::Position *pos() const {
    return GetStruct<const DX12ModelData::Position *>(VT_POS);
  }
  const DX12ModelData::Normal *norm() const {
    return GetStruct<const DX12ModelData::Normal *>(VT_NORM);
  }
  const DX12ModelData::UV *uv() const {
    return GetStruct<const DX12ModelData::UV *>(VT_UV);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<DX12ModelData::Position>(verifier, VT_POS) &&
           VerifyField<DX12ModelData::Normal>(verifier, VT_NORM) &&
           VerifyField<DX12ModelData::UV>(verifier, VT_UV) &&
           verifier.EndTable();
  }
};

struct VertexBuilder {
  typedef Vertex Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pos(const DX12ModelData::Position *pos) {
    fbb_.AddStruct(Vertex::VT_POS, pos);
  }
  void add_norm(const DX12ModelData::Normal *norm) {
    fbb_.AddStruct(Vertex::VT_NORM, norm);
  }
  void add_uv(const DX12ModelData::UV *uv) {
    fbb_.AddStruct(Vertex::VT_UV, uv);
  }
  explicit VertexBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Vertex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vertex>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vertex> CreateVertex(
    flatbuffers::FlatBufferBuilder &_fbb,
    const DX12ModelData::Position *pos = 0,
    const DX12ModelData::Normal *norm = 0,
    const DX12ModelData::UV *uv = 0) {
  VertexBuilder builder_(_fbb);
  builder_.add_uv(uv);
  builder_.add_norm(norm);
  builder_.add_pos(pos);
  return builder_.Finish();
}

struct Material FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaterialBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMB = 4,
    VT_DIF = 6,
    VT_SPE = 8,
    VT_N = 10
  };
  const DX12ModelData::Color *amb() const {
    return GetStruct<const DX12ModelData::Color *>(VT_AMB);
  }
  const DX12ModelData::Color *dif() const {
    return GetStruct<const DX12ModelData::Color *>(VT_DIF);
  }
  const DX12ModelData::Color *spe() const {
    return GetStruct<const DX12ModelData::Color *>(VT_SPE);
  }
  float n() const {
    return GetField<float>(VT_N, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<DX12ModelData::Color>(verifier, VT_AMB) &&
           VerifyField<DX12ModelData::Color>(verifier, VT_DIF) &&
           VerifyField<DX12ModelData::Color>(verifier, VT_SPE) &&
           VerifyField<float>(verifier, VT_N) &&
           verifier.EndTable();
  }
};

struct MaterialBuilder {
  typedef Material Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_amb(const DX12ModelData::Color *amb) {
    fbb_.AddStruct(Material::VT_AMB, amb);
  }
  void add_dif(const DX12ModelData::Color *dif) {
    fbb_.AddStruct(Material::VT_DIF, dif);
  }
  void add_spe(const DX12ModelData::Color *spe) {
    fbb_.AddStruct(Material::VT_SPE, spe);
  }
  void add_n(float n) {
    fbb_.AddElement<float>(Material::VT_N, n, 0.0f);
  }
  explicit MaterialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Material> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Material>(end);
    return o;
  }
};

inline flatbuffers::Offset<Material> CreateMaterial(
    flatbuffers::FlatBufferBuilder &_fbb,
    const DX12ModelData::Color *amb = 0,
    const DX12ModelData::Color *dif = 0,
    const DX12ModelData::Color *spe = 0,
    float n = 0.0f) {
  MaterialBuilder builder_(_fbb);
  builder_.add_n(n);
  builder_.add_spe(spe);
  builder_.add_dif(dif);
  builder_.add_amb(amb);
  return builder_.Finish();
}

struct ModelChild FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelChildBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERTICES = 4,
    VT_MATERIAL = 6,
    VT_INDICES = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<DX12ModelData::Vertex>> *vertices() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DX12ModelData::Vertex>> *>(VT_VERTICES);
  }
  const DX12ModelData::Material *material() const {
    return GetPointer<const DX12ModelData::Material *>(VT_MATERIAL);
  }
  const flatbuffers::Vector<uint32_t> *indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INDICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERTICES) &&
           verifier.VerifyVector(vertices()) &&
           verifier.VerifyVectorOfTables(vertices()) &&
           VerifyOffset(verifier, VT_MATERIAL) &&
           verifier.VerifyTable(material()) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyVector(indices()) &&
           verifier.EndTable();
  }
};

struct ModelChildBuilder {
  typedef ModelChild Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vertices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DX12ModelData::Vertex>>> vertices) {
    fbb_.AddOffset(ModelChild::VT_VERTICES, vertices);
  }
  void add_material(flatbuffers::Offset<DX12ModelData::Material> material) {
    fbb_.AddOffset(ModelChild::VT_MATERIAL, material);
  }
  void add_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> indices) {
    fbb_.AddOffset(ModelChild::VT_INDICES, indices);
  }
  explicit ModelChildBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ModelChild> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ModelChild>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModelChild> CreateModelChild(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DX12ModelData::Vertex>>> vertices = 0,
    flatbuffers::Offset<DX12ModelData::Material> material = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> indices = 0) {
  ModelChildBuilder builder_(_fbb);
  builder_.add_indices(indices);
  builder_.add_material(material);
  builder_.add_vertices(vertices);
  return builder_.Finish();
}

inline flatbuffers::Offset<ModelChild> CreateModelChildDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<DX12ModelData::Vertex>> *vertices = nullptr,
    flatbuffers::Offset<DX12ModelData::Material> material = 0,
    const std::vector<uint32_t> *indices = nullptr) {
  auto vertices__ = vertices ? _fbb.CreateVector<flatbuffers::Offset<DX12ModelData::Vertex>>(*vertices) : 0;
  auto indices__ = indices ? _fbb.CreateVector<uint32_t>(*indices) : 0;
  return DX12ModelData::CreateModelChild(
      _fbb,
      vertices__,
      material,
      indices__);
}

struct ModelParent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelParentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_CHILD = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DX12ModelData::ModelChild>> *child() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DX12ModelData::ModelChild>> *>(VT_CHILD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_CHILD) &&
           verifier.VerifyVector(child()) &&
           verifier.VerifyVectorOfTables(child()) &&
           verifier.EndTable();
  }
};

struct ModelParentBuilder {
  typedef ModelParent Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ModelParent::VT_NAME, name);
  }
  void add_child(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DX12ModelData::ModelChild>>> child) {
    fbb_.AddOffset(ModelParent::VT_CHILD, child);
  }
  explicit ModelParentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ModelParent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ModelParent>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModelParent> CreateModelParent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DX12ModelData::ModelChild>>> child = 0) {
  ModelParentBuilder builder_(_fbb);
  builder_.add_child(child);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<ModelParent> CreateModelParentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<DX12ModelData::ModelChild>> *child = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto child__ = child ? _fbb.CreateVector<flatbuffers::Offset<DX12ModelData::ModelChild>>(*child) : 0;
  return DX12ModelData::CreateModelParent(
      _fbb,
      name__,
      child__);
}

inline const DX12ModelData::ModelParent *GetModelParent(const void *buf) {
  return flatbuffers::GetRoot<DX12ModelData::ModelParent>(buf);
}

inline const DX12ModelData::ModelParent *GetSizePrefixedModelParent(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<DX12ModelData::ModelParent>(buf);
}

inline bool VerifyModelParentBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<DX12ModelData::ModelParent>(nullptr);
}

inline bool VerifySizePrefixedModelParentBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<DX12ModelData::ModelParent>(nullptr);
}

inline void FinishModelParentBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<DX12ModelData::ModelParent> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedModelParentBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<DX12ModelData::ModelParent> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace DX12ModelData

#endif  // FLATBUFFERS_GENERATED_DX12MODELDATA_DX12MODELDATA_H_
